# Modular Algebra

In mathematics, modular arithmetic is a system of arithmetic for integers, where numbers "wrap around" when reaching a certain value, called the modulus. The modern approach to modular arithmetic was developed by Carl Friedrich Gauss in his book Disquisitiones Arithmeticae, published in 1801. 

**In this notebooks we are only working with integers.**

## Building block

i mod m = remainder of the division i / m

In computing, the **modulo operation** returns the remainder or signed remainder of a division, after one number is divided by another (called the modulus of the operation).

Given two positive numbers a and n, a modulo n (abbreviated as a mod n) is the remainder of the Euclidean division of a by n, where a is the dividend and n is the divisor. The modulo operation is to be distinguished from the symbol mod, which refers to the modulus (or divisor) one is operating from. 

### Congruence   

Given an integer n > 1, called a modulus, two integers are said to be congruent modulo n, if n is a divisor of their difference (i.e., if there is an integer k such that a − b = kn).

Congruence modulo n is a congruence relation, meaning that it is an equivalence relation that is compatible with the operations of addition, subtraction, and multiplication. Congruence modulo n is denoted:

    a ≡ b ( mod n ) . {\displaystyle a\equiv b{\pmod {n}}.} {\displaystyle a\equiv b{\pmod {n}}.}

The parentheses mean that (mod n) applies to the entire equation, not just to the right-hand side (here b). This notation is not to be confused with the notation b mod n (without parentheses), which refers to the modulo operation. Indeed, b mod n denotes the unique integer a such that 0 ≤ a < n and a ≡ b ( mod n ) {\displaystyle a\equiv b\;({\text{mod}}\;n)} {\displaystyle a\equiv b\;({\text{mod}}\;n)} (i.e., the remainder of b {\displaystyle b} b when divided by n {\displaystyle n} n). 

The congruence relation may be rewritten as

    a = k n + b , {\displaystyle a=kn+b,} {\displaystyle a=kn+b,}

explicitly showing its relationship with Euclidean division. 

## Groups - Abstract Algebra

When working with Groups, the notation used is additive (+, identitiy element = 0) or multiplicative (x, identity element = 1).
This notation is used even when the elements of the group are not numerical, e.g., function compositions or geometric transformations.
Do the effort to get away from just Real numbers. 

\includegraphics[]{Images/bijection_injection.png}
[Source](https://en.wikipedia.org/wiki/Injective_function)

## The group of the modulo sum operation - Groups with additive notation

Recall that for a fixed $m$ all the possible values are

$G$ = {0, 1, 2, ..., $m$-1)

The elements with the modulo sum operation constitutes an **algebraic group** denoted as: ($G$, $+$). An algebraic group has the following properties (Example with m = 7, m is known as the order of the group):


* **Closure**: for any $a$ and $b$ in the set, the output of $(a + b)\%m $ must also be in the set.    

0+3 (mod 6), sum=3     
1+3 (mod 6), sum=4      
2+3 (mod 6), sum=5     
3+3 (mod 6), sum=0     
4+3 (mod 6), sum=1    
5+3 (mod 6), sum=2    

* **Associativity**: for any $a$, $b$ and $c$ in the set, $((a + b)\%m + c)\%m = (a + (b + c)\%m)\%m$       
   
$((3+5)\%7+2)\%7 = 3 = (3+(5+2)\%7)\%7$

* **Existence of identity**: There exist an element $e$ in the set such that for any $a$ in the set $(a + e)\%m = a$     

$(4+0)\%7 = 4\%7 = 4$     
In these cases, e=0, it is the identity element. 

* **Inverse Element**: For any element in ($G$, $+$) $a$ there must be another element $b$ such that $(a + b)\%m = e$       

m - a = b
7 - 3 = 4
$(3+ 4)\%7 = e = 0$


If additionally the operation is commutative ($(a+b)\%m$=$(b+a)\%m$) then we say that the group is **commutative** or **abelian**.

$(3+2)\%7 = 5 = (2+3)\%7)$
 

## Cyclic group

Cyclic group or monogenous group is a group that is generated by a single element, the generator g.
That is, it is a set of invertible elements with a single associative binary operation (In this case we provide the example of addition), and it contains an element g such that every other element of the group may be obtained by repeatedly applying the group operation (addition) to g or its inverse.
Each element can be written as a power of g in multiplicative notation (Operation is multiplicative), or as a multiple of g in additive notation (Operation is additive).  
[Source](https://en.wikipedia.org/wiki/Cyclic_group)  

𝐺={$𝑔^0,𝑔^1,...,𝑔^(𝑚−1)$}

Careful that this notation is not as in normal arithmetic.

For m = 8
E.g. 2 is not a generator of the group.     
2^1=2
2^2=(2+2^1)\%8=4
2^3=(2+2^2)\%8=6
2^4=(2+2^3)\%8=0
2^5=(2+2^4)\%8=2
2^6=(2+2^5)\%8=4
2^7=(2+2^6)\%8=6  

There are missing elements. But 1 is a g of the group:
1^1 = 1
1^2=2
1^3=3
1^4=4
1^5=5
1^6=6
1^7=7

Extra content ([Source](https://www.youtube.com/watch?v=8A84sA1YuPw))

\includegraphics[]{Images/additive.png}

## The group of the modulo multiplication operation - Groups with multiplicative notation

We can try to define a modulo group with the product operation instead of the sum. This algebraic group would be denoted as: (𝐺, ×) where 𝐺 again is the set of elements {0, 1, 2, ..., 𝑚-1} and × denoting the product operation

\includegraphics[]{Images/multiplicative.png}

We also have the properties of closure, associativity, and the identity (e=1) and the inverse elements. 

However, with integers, not all elements in a group necessarily have an inverse such that (a x inverse) = e = 1
For m=6, there is no inverse, but for m=7 there is. 
With m=7 then we have a group, with m=6 we do not. Prime numbers as m may form a group with multiplicative notation.

## Divisibility

Let 𝑎 and 𝑏 be integers with 𝑏!=0. We say that 𝑏 divides 𝑎, if there is an integer 𝑐 such that 𝑎=𝑏𝑐

E.g. 2 divides 8 because 𝑐=4 as 4*2 is 8

Let a and b be positive integers. Then we say that a divided by b has quotient q and remainder r if 𝑎=𝑏𝑞+𝑟 with 0≤𝑟<𝑏.

When we say that b divides a, we mean that there is no reminder. We would tstae otherwise

A common divisor of two integers 𝑎 and 𝑏 is a positive integer 𝑑 that divides both of them. 
The greatest common divisor is the largest of the divisors of these two integers. 

The [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm) is used to find the greatest common divisor.
[Proof](https://www.youtube.com/watch?v=H_2_nqKAZ5w)

In arithmetic and computer programming, the extended Euclidean algorithm is an extension to the Euclidean algorithm, and computes, in addition to the greatest common divisor (gcd) of integers a and b, also the coefficients of Bézout's identity, which are integers x and y such tha
𝑎𝑢+𝑏𝑣=𝑔𝑐𝑑(𝑎,𝑏)
This is a certifying algorithm, because the gcd is the only number that can simultaneously satisfy this equation and divide the inputs. It allows one to compute also, with almost no extra cost, the quotients of a and b by their greatest common divisor. 
[Source](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)

We want to find the inverse 𝑢 of an arbitrary number 𝑎<𝑚 in the product modulo 𝑚

, therefore

𝑎𝑢=1 (mod m)

Let's take the 𝑔𝑐𝑑(𝑎,𝑚)=𝑑

𝑎𝑢=1+𝑚𝑦

for some 𝑦

to be found. Rearranging the previous equation.

𝑎𝑢−𝑚𝑦=1

We divide now 𝑑
to both sides of the previous equation. Since 𝑑 is a common factor for 𝑎 and 𝑚 we know that the left hand side is an integer, but the right hand side would be a real number, therefore 𝑑

has to be 1.

Therefore, 𝑎
moudulo 𝑚 has an inverse in multiplication if and only if gcd(𝑎,𝑚)=1.

We can use the extended euclidean algorithm to find the inverse modulo 𝑚
for an integer 𝑎. Since we know that gcd(𝑎, 𝑚)=1, we can write

𝑎𝑢+𝑚𝑣=𝑔𝑐𝑑(𝑎,𝑚)=1

This means that

𝑎𝑢−1=−𝑚𝑣

And if we apply the modulo 𝑚

to both sides we get

𝑎𝑢−1=0 (mod m)

or

𝑎𝑢=1 (mod m)

and therefore 𝑢 is the inverse of 𝑎 in modulo 𝑚.

Conclusion:

𝑎 has an inverse modulo 𝑚 if 𝑎 and 𝑚 don't have a common divisor (gcd(a,m)=1) if 𝑚 is prime (𝑝), gcd(𝑎,𝑝)=1 if 𝑎<𝑝.  
If 𝑚 =𝑝, a prime number, then (𝐺, ×) is an  (commutative) a group.

## Groups, Rings, and Fields

\includegraphics[]{Images/summary.png}

\includegraphics[]{Images/rings.png}
the group for the second operations does not have inverses (Top right square).

A ring is an ordered triple, (𝑅,+,×), where 𝑅 is a set, +:𝑅×𝑅→𝑅 and ×:𝑅×𝑅→𝑅

are binary operations (usually written in in-fix notation) such that:

1. + is associative.
2. There exists 0∈𝑅 such that 0+𝑎=𝑎+0=𝑎 for all 𝑎∈𝑅.  
3. For every 𝑎∈𝑅:  there exists 𝑏∈𝑅 such that 𝑎+𝑏=𝑏+𝑎=0.   
4. + is commutative.   
5. × is associative.  
6. × distributes over + on the left: for all 𝑎,𝑏,𝑐∈𝑅, 𝑎×(𝑏+𝑐)=(𝑎×𝑏)+(𝑎×𝑐).    
7. × distributes over + on the right: for all 𝑎,𝑏,𝑐∈𝑅, (𝑏+𝑐)×𝑎=(𝑏×𝑎)+(𝑐×𝑎).     

1-4 tell us that (𝑅,+)
is an abelian group. 5 tells us that (𝑅,×) is a semigroup. 

\includegraphics[]{Images/Fields.png}

We also have the following items:

a. There exists 1∈𝑅 such that 1×𝑎=𝑎×1=𝑎 for all 𝑎∈𝑅
b. 1≠0 
c. For every 𝑎∈𝑅, 𝑎≠0, there exists 𝑏∈𝑅 such that 𝑎×𝑏=𝑏×𝑎=1
d. × is commutative.

A ring that satisfies (1)-(7)+(a) is said to be a "ring with unity." Clearly, every ring with unity is also a ring; it takes "more" to be a ring with unity than to be a ring.

A ring that satisfies (1)-(7)+(a,b,c) is said to be a division ring. Again, eveyr division ring is a ring, and it takes "more" to be a division ring than to be a ring. (5)+(a)+(b)+(c) tell us that (𝑅−{0},×)
is a group (note that we need to remove 0

because (c) specifies nonzero, and we need (b) to ensure we are left with something).

A ring that satisfies (1)-(7)+(a,b,c,d) is a field. Again, every field is a ring.

We do indeed have that (𝑅,+) is an abelian group, that (𝑅−{0},×) is an abelian group, and that these structures "mesh together" via (6) and (7). In a ring, we have that (𝑅,+) is an abelian group, that (𝑅,×) is a semigroup (or better yet, a semigroup with 0), and that the two structures "mesh well".

We have that every field is a division ring, but there are division rings that are not fields (e.g., the quaternions); every division ring is a ring with unity, but there are rings with unity that are not division rings (e.g., the integers if you want commutativity, the 𝑛×𝑛
matrices with coefficients in, say, ℝ, 𝑛>1, if you want noncommutativity); every ring with unity is a ring, but there are rings that are not rings with unity (strictly upper triangular 3×3 matrices with coefficients in ℝ, for instance).

So
Fields⊊Division rings⊊Rings with unity⊊Rings
and
Fields⊊Commutative rings with unity⊊Commutative rings⊊Rings.

[Source](https://math.stackexchange.com/questions/141249/what-is-difference-between-a-ring-and-a-field)

## Prime numbers

Prime numbers are of crucial importance in cryptography. This is why it is important to learn their properties and how to generate them in a fast and reliable way.
Definition: A prime number is a number that is only divisible by himself and 1. Equivalently 𝑝 is a prime number if gcd(𝑎, 𝑝)=1 for all 𝑎 smaller than 𝑝. 
Some facts about prime numbers:

    There are infinite number of prime numbers
    There is no formula to calculate the nth prime number

The **fundamental theorem of arithmetics** states that: every integer greater than 1 either is a prime number itself or can be represented as the product of prime numbers. Furthermore this representation is unique

𝑎=𝑝1^e1𝑝2^e2⋯𝑝𝑟^e𝑟

where 𝑝 is are prime numbers and 𝑒s the exponentiation of them. E.g. 5568=26∗3∗29, where 2, 3 and 29 are prime numbers. And the **factorization is unique**.

Even though we can’t predict primes with a formula we can calculate the probability of finding a prime number in between a range of numbers. We define 𝜋(x) as the number of prime numbers smaller than x. For instance, 𝜋(20)=8, because prime numbers smaller than 20 are {2, 3, 5, 7, 11, 13, 17, 19}. Therefore, to calculate the number of primes between 𝑥2 and 𝑥1 (𝑥2>𝑥1) we just need to subtract both 𝜋(𝑥2)-𝜋(𝑥1). Here 𝜋

(x) is exact calculation and we have to do it numerically. The prime number theorem establishes the asymptotic distribution of prime numbers by approximating the count to x/ln(x)
Image

\includegraphics[]{Images/prime_number_density.png}

How can we calculate a list of primes that are smaller than 𝑛? We will use the **Sieve of Erathostenes**: build a list of all the natural numbers from 1 to n (n is the natural number below which you want all the primes) and remove all the multiples of the newly find prime.

Say we want the prime numbers smaller than n=120. The algorithm starts with 2, then you discard its multiples (4, 6, 8, …, 120), you go for 3 and you know it is prime because it hasn’t been discarded, so you eliminate multiples of 3 that haven’t been discarded (6, 9, 12, 15…). The next number is 4 and has been discarded so you go to 5 and add it as prime, then eliminate its multiples…

Small pit stop, Python code:
yield is a keyword in Python that is used to return from a function without destroying the states of its local variable and when the function is called, the execution starts from the last yield statement. Any function that contains a yield keyword is termed as generator. Hence, yield is what makes a generator.
Since it stores the local variable states, hence overhead of memory allocation is controlled.
Since the old state is retained, flow doesn’t start from the beginnning and hence saves time.
The possible practical application is that when handling the last amount of data and searching particulars from it, yield can be used as we don’t need to lookup again from start and hence would save time. 

**Fermat's little theorem** states that if p is a prime number, then for any integer a, the number a^p − a is an integer multiple of p. In the notation of modular arithmetic, this is expressed as 𝑎^𝑝=𝑎 (mod p)
where 𝑎𝑝 means multiplying 𝑎, 𝑝 times and apply modulo 𝑝.

In the group of integers 0, 1, ... 𝑝-1 with multiplication modulo 𝑝 we can easily find the inverse with Fermat's little theorem (We know that a has an inverse, it belongs to a group):

𝑎^𝑝=𝑎 (mod p)

We just need to multiply by the inverse to the left and to the right of the equation two times

𝑎^𝑝−2=𝑎^−1 (mod p)

so the inverse is:

𝑎^−1=𝑎^𝑝−2 (mod p)

**Primality testing: Miller Rabin algorithm**  
The Fermat's theorem to find the inverse modulo 𝑝 only works when 𝑝 is prime, we need a way to predict if a number is prime or not in a fast way. Also, there are many cases in which we will be given very large numbers so calculate all of them with the Sieve of Erathostenes is not practical. Here we need a set of algorithms that "test" if a number is prime or not.
If 𝑎𝑝=𝑎 (mod p) is met, for a particular 𝑝 that does not mean that 𝑝 is a prime number
To ensure a number is prime, we use Miller Rabin algorithm.    

Even though 𝑝 accomplishing the equation of Fermat's little theorem does not mean 𝑝 is prime, is a good indicative that 𝑝

may be prime. After all if the Fermat's little equation is not fullfilled we know for sure that the number we are dealing with is not prime. That's what we are going to exploit in our seccond attempt

Let 𝑝 be a prime number different from 2, then we can write

𝑝−1=2^𝑘 q

where q is an odd number and 𝑘 an integer. We can do this because we know that 2 is the only even prime number and therefore p-1 must be even if the prime number is larger than 2. For 𝑝−1 being even we can factor it as a product of 𝑘 times 2, times an even number.

Let 𝑎 be a number not divisible by 𝑝, then one of the following two conditions is true:

𝑎𝑞−1=0 (mod p)
𝑎𝑐𝑞+1=0 (mod p)

for 𝑐 in 0,1,⋯,2𝑘. You can find a proof of this proposition in the book of Hoffstein, Pipher and Silverman. This happens strictly when 𝑝 is prime, let's try to see if these equations are true for arbitrary integer 𝑛. We take 
𝑛−1=2𝑘𝑞
If we find an 𝑎 for which the two conditions above are not true, then for sure 𝑛 is a composite number. 𝑎 is called a witness for the compositneess of 𝑛. This is what we do in the Miller-Rabin primality testing:

The Miller Rabin primality testing inputs an integer 𝑛 for which we want to test if it's prime or not and a potential composite witness 𝑎. If the two equations above are not true, then we know for sure that 𝑛 is composite

In short: if we find a witness a, then n is not prime, otherwise, depending on how many test you have run, you can be very sure that n is prime.
How sure we are that the number tested is prime?

Proposition: Let 𝑛 be an odd composite number, then at least 75\% of the numbers between 1 and 𝑛-1 are Miller-Rabin witnesses for 𝑛. Proof in the book of Hoffstein, Pipher and Silverman. For random 𝑎 the probability for it not being a witness is 25\%, therefore the probability of not finding 10 witnesses at random if 𝑎 is composite is 0.2510, i.e. If no witnesses are found in 10 rounds, then the probability for 𝑎 being prime is 1−0.2510= 0.999999

**Mersenne primes**

Some primes can be expressed as 𝑝=2^𝑛-1. Those primes are called Mersenne primes. Use the Miller-Rabin primality testing algorithm to find the maximum 𝑛 smaller than 1000 such tat 2𝑛-1 is a prime number.

### Factorization

Composite numbers are numbers that are not prime and thus can be factored as a unique product of primes. To crack the RSA, one must find the primes that compose a composite numbers, but these primes are too large for the attack to be feasible. One of the notebooks implements a non-efficient factorization using primes, however, there are other methods that are more efficient. 

###  The group of $(\mathbb{Z}/p\mathbb{Z})^*$ 

$G$ = {1, 2, ..., $p$-1) are the elements of the group where $p$ is a prime number.
$\times$(mod $p$) is the product modulo operation. We call this group  $(\mathbb{Z}/p\mathbb{Z})^*$ or $\mathbb{F}_p^*$. The asterisk indicate that we are removing the element 0.


Glossary:  

In mathematics, **function composition** is an operation that takes two functions f and g and produces a function h such that h(x) = g(f(x))  
In mathematics, a **geometric transformation** is any bijection of a set to itself (or to another such set) with some salient geometrical underpinning. More specifically, it is a function whose domain and range are sets of points — most often both R 2 {\displaystyle \mathbb {R} ^{2}} \mathbb {R} ^{2} or both R 3 {\displaystyle \mathbb {R} ^{3}} \mathbb {R} ^{3} — such that the function is injective so that its inverse exists.

In mathematics, a **bijection**, bijective function, one-to-one correspondence, or invertible function, is a function between the elements of two sets, where each element of one set is paired with exactly one element of the other set, and each element of the other set is paired with exactly one element of the first set.  There are no unpaired elements. In mathematical terms, a bijective function f: X → Y is a one-to-one (injective) and onto (surjective) mapping of a set X to a set Y.
In mathematics, an **injective** function (also known as injection, or one-to-one function) is a function that maps distinct elements of its domain to distinct elements of its codomain. In other words, every element of the function's range is the image of at most one element of its domain. The term one-to-one function must not be confused with one-to-one correspondence that refers to bijective functions, which are functions such that each element in the codomain is an image of exactly one element in the domain.  
In mathematics, a function f from a set X to a set Y is **surjective** (also known as onto, or a surjection), if for every element y in the codomain Y of f, there is at least one element x in the domain X of f such that f(x) = y. It is not required that x be unique; the function f may map one or more elements of X to the same element of Y.   (Not all values in the codomain of f are in the range of f)

Symbol ≡
    1.  Denotes an identity, that is, an equality that is true whichever values are given to the variables occurring in it.
    2.  In number theory, and more specifically in modular arithmetic, denotes the congruence modulo an integer.


